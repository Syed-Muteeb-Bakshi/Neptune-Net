<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeptuneNet â€“ AI-Powered Marine Ecosystem Impact Predictor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* A lighter background for day mode */
            color: #1e293b; /* Darker text for day mode */
        }
        .glass-panel {
            background: rgba(255, 255, 255, 0.6); /* Lighter, glassy panel */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }
        #map-container {
            background-color: #a7d7f9; /* A light blue for the ocean fallback */
            position: relative;
            width: 100%;
            aspect-ratio: 2 / 1; 
            z-index: 0;
        }
        /* Adjust popups for day mode */
        .leaflet-popup-content-wrapper {
            background: #ffffff;
            color: #1e293b;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .leaflet-popup-tip {
            background: #ffffff;
        }
        .leaflet-popup-close-button {
            color: #1e293b !important;
        }
        .dot {
            height: 12px;
            width: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
            vertical-align: middle;
        }
        .dot-blue { background-color: #3b82f6; box-shadow: 0 0 6px #3b82f6; }
        .dot-yellow { background-color: #facc15; box-shadow: 0 0 6px #facc15; }
        .dot-red { background-color: #ef4444; box-shadow: 0 0 6px #ef4444; }
        .dot-purple { background-color: #a855f7; box-shadow: 0 0 6px #a855f7; }
        
        /* AI Modal Styles */
        #ai-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        #ai-modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        #ai-modal {
            background: white;
            padding: 2rem;
            border-radius: 1rem;
            width: 90%;
            max-width: 600px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            transform: scale(0.95);
            transition: transform 0.3s ease;
        }
         #ai-modal-overlay.visible #ai-modal {
            transform: scale(1);
        }
    </style>
</head>
<body class="antialiased">

    <!-- Main Application Container -->
    <div class="max-w-7xl mx-auto p-4 sm:p-6 lg:p-8">

        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold tracking-tight text-slate-900">NeptuneNet</h1>
            <p class="mt-2 text-lg text-slate-600">AI-Powered Marine Ecosystem Impact Predictor</p>
        </header>

        <!-- Main Content: Map and Info Panels -->
        <main>
            <!-- Map Visualization -->
            <div id="map-container" class="rounded-lg shadow-2xl shadow-blue-500/10 overflow-hidden border border-gray-200">
                <!-- This hidden canvas is a clever trick to detect land vs. ocean -->
                <canvas id="maskCanvas" class="hidden"></canvas>
            </div>

            <!-- Information & Legend Panel -->
            <div class="mt-8 grid grid-cols-1 md:grid-cols-3 gap-6">
                
                <!-- Panel 1: Legend -->
                <div class="glass-panel rounded-lg p-6">
                    <h2 class="text-lg font-semibold text-slate-800 mb-2">Debris & Impact Legend</h2>
                    <ul class="space-y-3 text-slate-700 mt-4">
                        <li class="flex items-center"><span class="dot dot-blue"></span> Low Impact (0-7 days)</li>
                        <li class="flex items-center"><span class="dot dot-yellow"></span> Medium Impact (7-30 days)</li>
                        <li class="flex items-center"><span class="dot dot-red"></span> High Impact (30+ days)</li>
                        <li class="flex items-center"><span class="dot dot-purple"></span> Oil Spill (Any Age)</li>
                    </ul>
                </div>

                <!-- Panel 2: Debris Statistics & Controls -->
                <div class="glass-panel rounded-lg p-6">
                    <h2 class="text-lg font-semibold text-slate-800 mb-4">Generated Debris Statistics</h2>
                    <div class="space-y-3 text-slate-700">
                        <p>Total Debris Paths: <span id="debris-count" class="font-bold text-slate-900">0</span></p>
                        <p>Plastic/Other Points: <span id="plastic-count" class="font-bold text-sky-600">0</span></p>
                        <p>Oil Spills: <span id="oil-count" class="font-bold text-purple-600">0</span></p>
                    </div>
                </div>

                <!-- Panel 3: About -->
                 <div class="glass-panel rounded-lg p-6">
                    <h2 class="text-lg font-semibold text-slate-800 mb-4">About This Simulation</h2>
                    <p class="text-slate-600 text-sm">This is a conceptual demonstration of NeptuneNet. It generates static paths for marine debris within realistic oceanic gyres. The trail colors indicate increasing environmental impact over time.</p>
                </div>

            </div>
        </main>
    </div>

    <!-- AI Modal -->
    <div id="ai-modal-overlay">
        <div id="ai-modal">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold text-slate-800">AI Impact Analysis</h2>
                <button onclick="closeAIModal()" class="text-slate-500 hover:text-slate-800 text-3xl leading-none">&times;</button>
            </div>
            <div id="ai-modal-content" class="text-slate-600 leading-relaxed">
                <p>Generating analysis...</p>
            </div>
        </div>
    </div>


    <script>
        // --- AI MODAL SCRIPT ---
        const modalOverlay = document.getElementById('ai-modal-overlay');
        const modalContent = document.getElementById('ai-modal-content');

        function showAIModal() {
            modalOverlay.classList.add('visible');
        }

        function closeAIModal() {
            modalOverlay.classList.remove('visible');
        }

        async function analyzeImpact(type, lat, lon, timestamp) {
            showAIModal();
            modalContent.innerHTML = '<p>Generating analysis with NeptuneNet AI...</p>';
            
            const now = new Date();
            const time = new Date(timestamp);
            const ageDays = Math.floor((now - time) / (1000 * 60 * 60 * 24));
            let ageDescription = `over ${ageDays} days`;
            if (ageDays < 1) ageDescription = "less than a day";
            else if (ageDays < 30) ageDescription = `${ageDays} days`;
            else ageDescription = "over a month";

            const userQuery = `Act as a marine biologist. A '${type}' debris event, approximately ${ageDescription} old, has been located at latitude ${lat.toFixed(2)}, longitude ${lon.toFixed(2)}. Provide a brief, one-paragraph analysis of the potential ecological impact on local marine life and the surrounding ecosystem. Focus on the specific type of debris.`;

            const apiKey = ""; // Canvas will provide this
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: userQuery }] }] })
                });

                if (!response.ok) {
                    throw new Error(`API Error: ${response.status}`);
                }

                const result = await response.json();
                const text = result.candidates?.[0]?.content?.parts?.[0]?.text;

                if (text) {
                    modalContent.innerHTML = `<p>${text.replace(/\n/g, '<br>')}</p>`;
                } else {
                    throw new Error("No content received from AI.");
                }

            } catch(error) {
                console.error("AI Analysis Error:", error);
                modalContent.innerHTML = `
                    <p class="text-red-500 font-semibold">Sorry, the AI analysis could not be completed.</p>
                    <p class="mt-2 text-sm text-slate-500">You can copy the generated prompt below to use it elsewhere:</p>
                    <textarea readonly class="w-full h-40 mt-2 p-2 border rounded bg-slate-50 text-sm">${userQuery}</textarea>`;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const maskCanvas = document.getElementById('maskCanvas');
            const maskCtx = maskCanvas.getContext('2d');
            const mapContainer = document.getElementById('map-container');
            let maskImageData = null;
            let canvasSize = { width: 0, height: 0 };

            // --- DEBRIS SPAWN ZONE DATA ---
            // These polygons define where new debris paths can start.
            // They are larger than the garbage patches themselves and avoid land.
            const spawnZones = [
                { name: 'North Pacific', bounds: { minLat: 25, maxLat: 45, minLon: -160, maxLon: -130 } },
                { name: 'South Pacific', bounds: { minLat: -35, maxLat: -15, minLon: -115, maxLon: -85 } },
                { name: 'North Atlantic', bounds: { minLat: 20, maxLat: 40, minLon: -75, maxLon: -20 } },
                { name: 'South Atlantic', bounds: { minLat: -40, maxLat: -15, minLon: -35, maxLon: 10 } },
                { name: 'Indian Ocean', bounds: { minLat: -50, maxLat: 10, minLon: 50, maxLon: 95 } }
            ];

            // --- INITIALIZE LEAFLET MAP ---
            const map = L.map('map-container', {
                center: [20, 0],
                zoom: 2,
                attributionControl: false,
                maxBounds: [[-90, -180], [90, 180]], // Sets the boundaries of the map
                maxBoundsViscosity: 1.0 // Makes the bounds solid
            });

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);
            
            const mapImage = new Image();
            mapImage.crossOrigin = "Anonymous";
            mapImage.src = 'https://i.imgur.com/2A5tE9A.png';

            mapImage.onload = function() {
                const size = map.getSize();
                if (size.x === 0 || size.y === 0) {
                    setTimeout(mapImage.onload, 100);
                    return;
                }
                canvasSize.width = maskCanvas.width = size.x;
                canvasSize.height = maskCanvas.height = size.y;
                maskCtx.drawImage(mapImage, 0, 0, canvasSize.width, canvasSize.height);
                try {
                    maskImageData = maskCtx.getImageData(0, 0, canvasSize.width, canvasSize.height);
                    plotInitialData();
                } catch (e) {
                    console.error("Failed to get image data from canvas:", e);
                }
            };
            
            // --- LAND DETECTION LOGIC ---
            function isPixelLand(x, y) {
                 if (!maskImageData) return true;
                 if (x < 0 || x >= canvasSize.width || y < 0 || y >= canvasSize.height) return true;
                 const pixelIndex = (Math.floor(y) * canvasSize.width + Math.floor(x)) * 4;
                 if (pixelIndex >= maskImageData.data.length || pixelIndex < 0) return true;
                 const r = maskImageData.data[pixelIndex];
                 return r > 45;
            }

            function isLand(x, y) {
                if (y / canvasSize.height > 0.85) return true;
                if (isPixelLand(x, y)) return true;
                const radius = 8;
                const step = 2;
                let landNeighbors = 0;
                let totalNeighbors = 0;
                for (let dx = -radius; dx <= radius; dx += step) {
                    for (let dy = -radius; dy <= radius; dy += step) {
                        if (dx === 0 && dy === 0) continue;
                        if (isPixelLand(x + dx, y + dy)) landNeighbors++;
                        totalNeighbors++;
                    }
                }
                return (landNeighbors / totalNeighbors) > 0.4;
            }

            // --- DEBRIS GENERATION LOGIC ---
            function getRandomOceanCoordInZone() {
                // 1. Pick a random spawn zone
                const zone = spawnZones[Math.floor(Math.random() * spawnZones.length)].bounds;
                
                let lat, lon, point, attempts = 0;
                do {
                    // 2. Generate a random point *inside* that zone
                    lat = zone.minLat + Math.random() * (zone.maxLat - zone.minLat);
                    lon = zone.minLon + Math.random() * (zone.maxLon - zone.minLon);
                    point = map.latLngToContainerPoint([lat, lon]);
                    attempts++;
                } while (isLand(point.x, point.y) && attempts < 200); // 3. Check if it's on land
                
                if(attempts >= 200) return { lat: 20, lon: -150 }; // Fallback
                return { lat, lon };
            }

            function getColor(type, timestamp) {
                const now = new Date();
                const time = new Date(timestamp);
                const ageDays = (now - time) / (1000 * 60 * 60 * 24);
                if (type === 'oil') return '#a855f7';
                if (ageDays < 7) return '#3b82f6';
                if (ageDays < 30) return '#facc15';
                return '#ef4444';
            }

            function generateGarbageData(count) {
                const data = [];
                const now = new Date();
                let oilSpillCount = Math.floor(Math.random() * 2) + 1;
                let plasticCount = count - oilSpillCount;
                const types = Array(oilSpillCount).fill('oil').concat(Array(plasticCount).fill('plastic'));
                for (let i = types.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [types[i], types[j]] = [types[j], types[i]];
                }
                for (const type of types) {
                    const path = [];
                    let { lat: currLat, lon: currLon } = getRandomOceanCoordInZone(); // Use the new function
                    let timestamp = new Date(now.getTime() - Math.random() * 90 * 24 * 60 * 60 * 1000);
                    const segments = 5 + Math.floor(Math.random() * 5);
                    for (let j = 0; j < segments; j++) {
                        path.push({ lat: currLat, lon: currLon, timestamp: timestamp.toISOString() });
                        const lastLat = currLat, lastLon = currLon;
                        let attempts = 0;
                        do {
                            currLat = lastLat + (Math.random() - 0.5) * 5;
                            currLon = lastLon + (Math.random() - 0.5) * 5;
                            const point = map.latLngToContainerPoint([currLat, currLon]);
                            if (!isLand(point.x, point.y)) break; 
                            attempts++;
                        } while (attempts < 10);
                        if (attempts >= 10) break;
                        timestamp = new Date(timestamp.getTime() + (1 + Math.random() * 5) * 24 * 60 * 60 * 1000);
                    }
                    if(path.length > 1) data.push({ type, path });
                }
                document.getElementById('debris-count').textContent = count;
                document.getElementById('plastic-count').textContent = plasticCount;
                document.getElementById('oil-count').textContent = oilSpillCount;
                return data;
            }

            // --- PLOTTING FUNCTIONS ---
            function plotGarbagePatches() {
                const patches = [
                    { name: 'North Pacific Garbage Patch', coords: [[35, -135], [42, -135], [42, -155], [35, -155]] },
                    { name: 'South Pacific Garbage Patch', coords: [[-20, -90], [-30, -90], [-30, -110], [-20, -110]] },
                    { name: 'North Atlantic Garbage Patch', coords: [[25, -40], [35, -40], [35, -70], [25, -70]] },
                    { name: 'South Atlantic Garbage Patch', coords: [[-20, 0], [-30, 0], [-30, -30], [-20, -30]] },
                    { name: 'Indian Ocean Garbage Patch', coords: [[-15, 70], [-25, 70], [-25, 90], [-15, 90]] }
                ];

                patches.forEach(patch => {
                    const polygon = L.polygon(patch.coords, {
                        color: 'rgba(139, 69, 19, 0.5)', 
                        fillColor: 'rgba(139, 69, 19, 0.2)',
                        weight: 1
                    }).addTo(map);
                    const popupText = `<b>${patch.name}</b><br>A major zone of marine debris accumulation.<br><small>Approx. Coords: ${patch.coords[0].join(', ')} to ${patch.coords[2].join(', ')}</small>`;
                    polygon.bindPopup(popupText);
                });
            }
            
            function plotStaticDebris() {
                const staticDebris = [
                    { type: 'plastic', path: [{ lat: 10.5, lon: 72.5, timestamp: new Date(Date.now() - 40 * 24*60*60*1000).toISOString() }, { lat: 10.8, lon: 72.8, timestamp: new Date(Date.now() - 38 * 24*60*60*1000).toISOString() }, { lat: 11, lon: 73.2, timestamp: new Date().toISOString() }] },
                    { type: 'plastic', path: [{ lat: 11.5, lon: 72.0, timestamp: new Date(Date.now() - 60 * 24*60*60*1000).toISOString() }, { lat: 11.7, lon: 72.4, timestamp: new Date(Date.now() - 55 * 24*60*60*1000).toISOString() }, { lat: 11.9, lon: 72.9, timestamp: new Date().toISOString() }] }
                ];
                 staticDebris.forEach(item => plotPath(item));
            }

            function plotPath(item) {
                const path = item.path;
                for (let i = 0; i < path.length - 1; i++) {
                    const startPoint = path[i], endPoint = path[i+1];
                    const startTime = new Date(startPoint.timestamp).getTime(), endTime = new Date(endPoint.timestamp).getTime();
                    const subSegments = 10;
                    for(let j = 0; j < subSegments; j++) {
                        const ratio = j / subSegments, nextRatio = (j + 1) / subSegments;
                        const currentLat = startPoint.lat + (endPoint.lat - startPoint.lat) * ratio;
                        const currentLon = startPoint.lon + (endPoint.lon - startPoint.lon) * ratio;
                        const currentPointOnMap = map.latLngToContainerPoint([currentLat, currentLon]);
                        if (isLand(currentPointOnMap.x, currentPointOnMap.y)) continue;
                        const currentTime = new Date(startTime + (endTime - startTime) * ratio).toISOString();
                        const nextLat = startPoint.lat + (endPoint.lat - startPoint.lat) * nextRatio;
                        const nextLon = startPoint.lon + (endPoint.lon - startPoint.lon) * nextRatio;
                        const color = getColor(item.type, currentTime);
                        L.polyline([[currentLat, currentLon], [nextLat, nextLon]], { color: color, weight: 3, opacity: 0.8 }).addTo(map);
                    }
                }
                const last = path[path.length - 1];
                const markerColor = getColor(item.type, new Date().toISOString());

                const popupContent = `<b>Type:</b> ${item.type}<br><b>Coords:</b> ${last.lat.toFixed(2)}, ${last.lon.toFixed(2)}<br><b>Last Seen:</b> ${last.timestamp.split('T')[0]}<br><button onclick="analyzeImpact('${item.type}', ${last.lat}, ${last.lon}, '${last.timestamp}')" class="mt-2 px-3 py-1 bg-blue-500 text-white text-xs rounded hover:bg-blue-600 transition-colors">Analyze Impact with AI</button>`;

                L.circleMarker([last.lat, last.lon], { radius: 5, color: markerColor, fillColor: markerColor, fillOpacity: 0.9 }).addTo(map).bindPopup(popupContent);
            }

            function plotGarbagePaths() {
                const debrisCount = Math.floor(Math.random() * 5) + 10; // 10-14
                const garbageData = generateGarbageData(debrisCount);
                garbageData.forEach(item => plotPath(item));
            }

            function plotInitialData() {
                plotGarbagePaths();
                plotStaticDebris();
                plotGarbagePatches();
            }
        });
    </script>
</body>
</html>

